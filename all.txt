New file: README.md
# fiap_global_solutions_2024

New file: checklist.md
## Checklist Global Solutions 2024.2 - Energia

**Tema:** Otimiza√ß√£o do consumo de energia em ambientes residenciais, comerciais ou urbanos utilizando Data Science, IoT, Python e Banco de Dados.

**Grupo:**  (Insira os nomes dos integrantes aqui)

**Entreg√°vel:** √önico PDF contendo todas as se√ß√µes abaixo + v√≠deo opcional (para concorrer ao pr√™mio).

**I. Artificial Intelligence Challenges (AIC) - 10%**

[ ] Ler o artigo: <https://www.sciencedirect.com/science/article/pii/S2666546822000544>
[ ] Desenvolver solu√ß√£o baseada em IA, IoT, Big Data para otimiza√ß√£o de consumo de energia em resid√™ncia (ou ambiente escolhido).
[ ] Escrever PDF com:
    [ ] Introdu√ß√£o (contextualiza√ß√£o, objetivos, desafios, barreiras)
    [ ] Desenvolvimento (justificativa das tecnologias, diagrama, etc.)
    [ ] Resultados Esperados (estimativa de economia, impacto no conforto, uso do equipamento, vida √∫til)
    [ ] Conclus√£o (refor√ßo do desenvolvimento e resultados esperados)


**II. Artificial Intelligence with Computer Systems and Sensors (AICSS) - 20%**

[x] Desenvolver circuito com ESP32 para otimizar ilumina√ß√£o interna e externa.
[x] Utilizar sensores (LDR, Ultrassom, ou alternativas descritas).
    [x] Considerar restri√ß√µes de seguran√ßa para ilumina√ß√£o externa (m√≠nimo de luminosidade).
[x] Simular solu√ß√£o no Wokwi.
[ ] Gravar v√≠deo demonstrativo (YouTube - modo "n√£o listado").
[ ] Escrever PDF com:
    [ ] Introdu√ß√£o
    [ ] Descri√ß√£o da solu√ß√£o
    [ ] C√≥digo-fonte
    [ ] Link do v√≠deo YouTube
    [ ] Conclus√£o (impactos positivos e negativos)


**III. Statistical Computing with R (SCR) - 20%**

[x] Escolher um banco de dados relevante de <https://dadosabertos.aneel.gov.br/organization/>.
[x] Realizar an√°lise explorat√≥ria de dados:
    [x] T√©cnicas de estat√≠stica descritiva (tabelas, gr√°ficos).
    [x] C√°lculo de medidas de tend√™ncia central, dispers√£o e separatrizes.
[x] Interpretar dados e propor insights pr√°ticos (inova√ß√£o, justi√ßa social, crescimento econ√¥mico, preserva√ß√£o ambiental).


**IV. Cognitive Data Science (CDS) - 20%**

[x] Armazenar consumo energ√©tico dos √∫ltimos anos (dados oficiais do Governo Federal).
[x] Utilizar bases de dados relacionais.
[-] Criar objetos de banco de dados para analisar tend√™ncias de consumo.
[x] Criar pipeline para filtrar dados do Brasil (demanda de energia el√©trica, consumo per capita, etc.).


**V. Computational Thinking with Python (CTWP) - 20%**

[ ] Desenvolver sistema automatizado em Python para gerenciamento e otimiza√ß√£o do consumo energ√©tico.
[ ] Interface de usu√°rio com visualiza√ß√£o de dados e relat√≥rios de efici√™ncia energ√©tica.
[ ] Monitoramento em tempo real de tarifas e consumo interno.
[ ] Sele√ß√£o autom√°tica da fonte de energia mais econ√¥mica e sustent√°vel.


**VI. Ir Al√©m - 10%**

[ ] Integrar Python com o banco de dados do CDS.
[ ] Ler e apresentar dados da solu√ß√£o AICSS (transferir dados do Wokwi manualmente, se necess√°rio).
[ ] Disparar an√°lises em R.
[ ] Gravar v√≠deo explicativo (YouTube - modo "n√£o listado", at√© 6 minutos).
[ ] Adicionar link do v√≠deo no PDF.


**VII. Entreg√°vel Final**

[ ] Criar logotipo do time (opcional).
[ ] Incluir nomes dos integrantes na primeira p√°gina do PDF.
[ ] Apresentar todas as solu√ß√µes detalhadamente (arquiteturas, justificativas, circuitos, c√≥digos).
[ ] Organizar o PDF com se√ß√µes claras (Introdu√ß√£o, Desenvolvimento, Resultados Esperados, Conclus√µes).
[ ] Incluir link do v√≠deo (opcional, para concorrer ao pr√™mio).


**Lembrete:**  A nota final considera todas as disciplinas do curso, mesmo que o peso do entreg√°vel seja distribu√≠do conforme o checklist.  Boa sorte!


New file: src/CDS/README.md
# An√°lise de Consumo de Energia El√©trica - Projeto GS

## üìä Sobre o Projeto

Este projeto faz parte da Global Solution, focando no desenvolvimento de uma solu√ß√£o baseada em Data Science, IoT e Python para otimizar o consumo de energia em diferentes ambientes (residenciais, comerciais e urbanos). O objetivo principal √© melhorar a efici√™ncia energ√©tica atrav√©s da an√°lise de dados hist√≥ricos e integra√ß√£o com fontes renov√°veis.

## üéØ Objetivos

- Analisar tend√™ncias hist√≥ricas de consumo de energia el√©trica
- Criar pipeline de dados para filtrar informa√ß√µes espec√≠ficas do Brasil
- Avaliar demanda energ√©tica e consumo per capita
- Identificar padr√µes de consumo para otimiza√ß√£o
- Integrar an√°lise com sistemas IoT para tomada de decis√£o em tempo real

## üìë Dados Dispon√≠veis

### Estrutura dos Dados

O conjunto de dados inclui as seguintes dimens√µes principais:

1. **Dimens√£o Temporal**
   - Data (AAAAMMDD)

2. **Tipo de Consumidor**
   - Cativo
   - Livre

3. **Localiza√ß√£o**
   - Sistema (Subsistema ou Sistemas Isolados)
   - UF (Unidade da Federa√ß√£o)

4. **Classifica√ß√£o de Consumo**
   - Setor Econ√¥mico (3 n√≠veis)
   - Tens√£o de Fornecimento (3 n√≠veis)
   - Faixas de Consumo (2 n√≠veis)

5. **M√©tricas**
   - N√∫mero de Consumidores
   - Consumo em MWh

### Detalhes Espec√≠ficos

- **Tens√£o de Fornecimento**:
  - Alta Tens√£o: ‚â• 69kV
  - Baixa Tens√£o: ‚â§ 1kV

- **Faixas de Consumo para Baixa Tens√£o**:
  - Convencional: 0-30 kWh, 31-100 kWh, 101-200 kWh, 201-300 kWh, 301-400 kWh, 401-500 kWh, 501-1000 kWh, > 1000 kWh
  - Baixa Renda: 0-30 kWh, 31-100 kWh, 101-200 kWh, > 200 kWh

## üîó Fontes de Dados

1. **Dados Processados**:
   - [Consumo de Energia El√©trica - EPE](https://www.epe.gov.br/pt/publicacoes-dados-abertos/publicacoes/consumo-de-energia-eletrica)

2. **Dados Brutos e Dicion√°rio**:
   - [Anu√°rio Estat√≠stico de Energia El√©trica - EPE](https://www.epe.gov.br/pt/publicacoes-dados-abertos/dados-abertos/dados-do-anuario-estatistico-de-energia-eletrica)

## üõ† Tecnologias Utilizadas

- Python para processamento e an√°lise de dados
- Banco de dados relacional para armazenamento
- Ferramentas de IoT para coleta de dados em tempo real
- Bibliotecas de Data Science para an√°lise preditiva

## üìà An√°lises Previstas

1. Tend√™ncias de consumo ao longo do tempo
2. Distribui√ß√£o por setor econ√¥mico
3. An√°lise comparativa entre regi√µes
4. Impacto das faixas de tens√£o no consumo
5. Rela√ß√£o entre n√∫mero de consumidores e consumo total
6. Padr√µes sazonais de consumo

## üéÅ Entreg√°veis Esperados

- Pipeline de dados automatizado
- An√°lises estat√≠sticas do consumo
- Dashboards interativos
- Modelos preditivos de consumo
- Documenta√ß√£o t√©cnica completa


## üíæ Configura√ß√£o do Banco de Dados

### Pr√©-requisitos
- PostgreSQL instalado
- Privil√©gios de administrador no banco de dados
- psql ou outro cliente SQL compat√≠vel com PostgreSQL

### Scripts de Configura√ß√£o

O banco de dados √© configurado em duas etapas, utilizando os seguintes scripts:

1. `src/initialize_database.sql`: Cria a estrutura inicial do banco de dados
2. `src/create_pipeline_views.sql`: Configura as views para an√°lise dos dados

#### Passo 1: Criar Estrutura do Banco de Dados

Execute o script `src/initialize_database.sql`:

```sql
-- Cria√ß√£o das tabelas dimensionais
CREATE TABLE DIM_TEMPO (
    data DATE PRIMARY KEY,
    ano INT,
    mes INT,
    trimestre INT,
    mes_nome VARCHAR(20),
    CONSTRAINT chk_mes CHECK (mes BETWEEN 1 AND 12),
    CONSTRAINT chk_trimestre CHECK (trimestre BETWEEN 1 AND 4)
);

CREATE TABLE DIM_LOCALIZACAO (
    id_localizacao SERIAL PRIMARY KEY,
    uf VARCHAR(2),
    sistema VARCHAR(50),
    regiao VARCHAR(20),
    populacao DECIMAL(12,2),
    CONSTRAINT chk_uf CHECK (uf ~ '^[A-Z]{2}$')
);

CREATE TABLE DIM_CONSUMIDOR (
    id_consumidor SERIAL PRIMARY KEY,
    tipo_consumidor VARCHAR(10),
    faixa_consumo_n1 VARCHAR(50),
    faixa_consumo_n2 VARCHAR(50),
    CONSTRAINT chk_tipo_consumidor CHECK (tipo_consumidor IN ('Cativo', 'Livre'))
);

CREATE TABLE DIM_TENSAO (
    id_tensao SERIAL PRIMARY KEY,
    tensao_n1 VARCHAR(50),
    tensao_n2 VARCHAR(50),
    tensao_n3 VARCHAR(50)
);

CREATE TABLE DIM_SETOR (
    id_setor SERIAL PRIMARY KEY,
    setor_n1 VARCHAR(50),
    setor_n2 VARCHAR(50),
    setor_n3 VARCHAR(50)
);

-- Cria√ß√£o da tabela fato
CREATE TABLE FATO_CONSUMO (
    id_consumo SERIAL PRIMARY KEY,
    data DATE,
    id_localizacao INT,
    id_consumidor INT,
    id_tensao INT,
    id_setor INT,
    consumo_mwh DECIMAL(12,2),
    numero_consumidores INT,
    FOREIGN KEY (data) REFERENCES DIM_TEMPO(data),
    FOREIGN KEY (id_localizacao) REFERENCES DIM_LOCALIZACAO(id_localizacao),
    FOREIGN KEY (id_consumidor) REFERENCES DIM_CONSUMIDOR(id_consumidor),
    FOREIGN KEY (id_tensao) REFERENCES DIM_TENSAO(id_tensao),
    FOREIGN KEY (id_setor) REFERENCES DIM_SETOR(id_setor)
);

-- √çndices para otimiza√ß√£o de consultas
CREATE INDEX idx_fato_consumo_data ON FATO_CONSUMO(data);
CREATE INDEX idx_fato_consumo_localizacao ON FATO_CONSUMO(id_localizacao);
CREATE INDEX idx_fato_consumo_setor ON FATO_CONSUMO(id_setor);
```

#### Passo 2: Criar Views de An√°lise

Execute o script `src/create_pipeline_views.sql`:

```sql
-- Cria√ß√£o de views para an√°lises espec√≠ficas

-- View para an√°lise de tend√™ncia de consumo mensal
CREATE VIEW vw_tendencia_consumo_mensal AS
SELECT 
    dt.ano,
    dt.mes,
    dl.uf,
    dl.sistema,
    SUM(fc.consumo_mwh) as consumo_total,
    SUM(fc.numero_consumidores) as total_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dt.mes, dl.uf, dl.sistema
ORDER BY dt.ano, dt.mes;

-- View para c√°lculo do consumo per capita por UF
CREATE VIEW vw_consumo_per_capita AS
SELECT 
    dt.ano,
    dl.uf,
    SUM(fc.consumo_mwh) as consumo_total,
    MAX(dl.populacao) as populacao,
    ROUND(SUM(fc.consumo_mwh) / MAX(dl.populacao), 2) as consumo_per_capita
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dl.uf
ORDER BY dt.ano, dl.uf;

-- View para an√°lise de demanda por setor econ√¥mico
CREATE VIEW vw_demanda_setor AS
SELECT 
    dt.ano,
    ds.setor_n1,
    ds.setor_n2,
    dl.regiao,
    SUM(fc.consumo_mwh) as consumo_total,
    COUNT(DISTINCT fc.id_consumidor) as num_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_SETOR ds ON fc.id_setor = ds.id_setor
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, ds.setor_n1, ds.setor_n2, dl.regiao
ORDER BY dt.ano, consumo_total DESC;
```

### Explica√ß√£o das Views de An√°lise

O script `create_pipeline_views.sql` cria tr√™s views principais para an√°lise dos dados. Abaixo est√° a explica√ß√£o detalhada de cada uma:

#### 1. View `vw_tendencia_consumo_mensal`

```sql
CREATE VIEW vw_tendencia_consumo_mensal AS
SELECT 
    dt.ano,
    dt.mes,
    dl.uf,
    dl.sistema,
    SUM(fc.consumo_mwh) as consumo_total,
    SUM(fc.numero_consumidores) as total_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dt.mes, dl.uf, dl.sistema
ORDER BY dt.ano, dt.mes;
```

**Retorno:**
| Coluna | Tipo | Descri√ß√£o |
|--------|------|-----------|
| ano | INT | Ano de refer√™ncia |
| mes | INT | M√™s de refer√™ncia (1-12) |
| uf | VARCHAR(2) | Sigla do estado |
| sistema | VARCHAR(50) | Nome do subsistema ou sistema isolado |
| consumo_total | DECIMAL | Soma total do consumo em MWh no per√≠odo |
| total_consumidores | INT | N√∫mero total de consumidores no per√≠odo |

**Uso:** An√°lise de tend√™ncias mensais de consumo por estado e sistema el√©trico.

#### 2. View `vw_consumo_per_capita`

```sql
CREATE VIEW vw_consumo_per_capita AS
SELECT 
    dt.ano,
    dl.uf,
    SUM(fc.consumo_mwh) as consumo_total,
    MAX(dl.populacao) as populacao,
    ROUND(SUM(fc.consumo_mwh) / MAX(dl.populacao), 2) as consumo_per_capita
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dl.uf
ORDER BY dt.ano, dl.uf;
```

**Retorno:**
| Coluna | Tipo | Descri√ß√£o |
|--------|------|-----------|
| ano | INT | Ano de refer√™ncia |
| uf | VARCHAR(2) | Sigla do estado |
| consumo_total | DECIMAL | Consumo total em MWh |
| populacao | DECIMAL | Popula√ß√£o do estado |
| consumo_per_capita | DECIMAL | Consumo m√©dio por habitante (MWh/habitante) |

**Uso:** An√°lise comparativa do consumo de energia por habitante entre diferentes estados.

#### 3. View `vw_demanda_setor`

```sql
CREATE VIEW vw_demanda_setor AS
SELECT 
    dt.ano,
    ds.setor_n1,
    ds.setor_n2,
    dl.regiao,
    SUM(fc.consumo_mwh) as consumo_total,
    COUNT(DISTINCT fc.id_consumidor) as num_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_SETOR ds ON fc.id_setor = ds.id_setor
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, ds.setor_n1, ds.setor_n2, dl.regiao
ORDER BY dt.ano, consumo_total DESC;
```

**Retorno:**
| Coluna | Tipo | Descri√ß√£o |
|--------|------|-----------|
| ano | INT | Ano de refer√™ncia |
| setor_n1 | VARCHAR(50) | Classifica√ß√£o prim√°ria do setor econ√¥mico |
| setor_n2 | VARCHAR(50) | Classifica√ß√£o secund√°ria do setor econ√¥mico |
| regiao | VARCHAR(20) | Regi√£o geogr√°fica |
| consumo_total | DECIMAL | Consumo total em MWh do setor |
| num_consumidores | INT | N√∫mero de consumidores √∫nicos no setor |

**Uso:** An√°lise setorial do consumo de energia, permitindo identificar os setores econ√¥micos com maior demanda por regi√£o.

### Exemplos de Consultas

```sql
-- Exemplo 1: Consumo mensal total em 2023 para S√£o Paulo
SELECT * FROM vw_tendencia_consumo_mensal 
WHERE ano = 2023 AND uf = 'SP';

-- Exemplo 2: Top 5 estados com maior consumo per capita em 2023
SELECT * FROM vw_consumo_per_capita 
WHERE ano = 2023 
ORDER BY consumo_per_capita DESC 
LIMIT 5;

-- Exemplo 3: Consumo por setor industrial na regi√£o Sudeste
SELECT * FROM vw_demanda_setor 
WHERE setor_n1 = 'Industrial' 
AND regiao = 'Sudeste' 
ORDER BY consumo_total DESC;
```

### Como Executar os Scripts

1. Abra o terminal ou prompt de comando
2. Conecte-se ao PostgreSQL usando psql:
```bash
psql -U seu_usuario -d seu_banco
```
3. Execute os scripts na ordem correta:
```bash
\i caminho/para/initialize_database.sql
\i caminho/para/create_pipeline_views.sql
```

### Verifica√ß√£o da Instala√ß√£o

Para verificar se tudo foi instalado corretamente, execute:

```sql
-- Verificar tabelas criadas
\dt

-- Verificar views criadas
\dv

-- Testar uma view
SELECT * FROM vw_tendencia_consumo_mensal LIMIT 5;
```

### Notas Importantes

- Certifique-se de ter backup dos dados antes de executar os scripts
- Os scripts devem ser executados com privil√©gios de administrador
- As constraints garantem a integridade dos dados
- Os √≠ndices otimizam as consultas mais frequentes
- As views facilitam a an√°lise dos dados
- Os scripts podem ser adaptados conforme necessidade

## üéØ Conclus√£o

Este projeto de an√°lise de consumo de energia el√©trica foi desenvolvido como parte da Global Solution, com foco em criar uma solu√ß√£o baseada em Data Science para otimiza√ß√£o do consumo energ√©tico. A estrutura implementada oferece:

### üìä Principais Funcionalidades
- An√°lise granular do consumo de energia por regi√£o, setor e per√≠odo
- Acompanhamento de tend√™ncias de consumo ao longo do tempo
- C√°lculo de m√©tricas per capita para compara√ß√µes entre regi√µes
- Base para integra√ß√£o com sistemas IoT e an√°lise em tempo real

### üí° Benef√≠cios
1. **Tomada de Decis√£o:**
   - Insights baseados em dados hist√≥ricos
   - Identifica√ß√£o de padr√µes de consumo
   - Suporte a decis√µes de efici√™ncia energ√©tica

2. **Sustentabilidade:**
   - Monitoramento do impacto de iniciativas de economia
   - Base para integra√ß√£o com fontes renov√°veis
   - Suporte a pol√≠ticas de redu√ß√£o de consumo

3. **Escalabilidade:**
   - Estrutura modular e expans√≠vel
   - Preparado para inclus√£o de novos dados
   - Facilidade de integra√ß√£o com outras ferramentas

### üöÄ Pr√≥ximos Passos
- Implementa√ß√£o de modelos preditivos
- Integra√ß√£o com sistemas IoT em tempo real
- Desenvolvimento de dashboards interativos
- Expans√£o para an√°lise de fontes renov√°veis
- Inclus√£o de vari√°veis clim√°ticas e sazonais

### üìà Impacto Esperado
O sistema desenvolvido tem potencial para contribuir significativamente com:
- Redu√ß√£o do consumo energ√©tico
- Otimiza√ß√£o de recursos
- Promo√ß√£o da sustentabilidade
- Conscientiza√ß√£o sobre uso de energia
- Suporte a pol√≠ticas p√∫blicas de efici√™ncia energ√©tica

Este projeto estabelece uma base s√≥lida para o desenvolvimento de solu√ß√µes mais avan√ßadas em efici√™ncia energ√©tica, combinando an√°lise de dados hist√≥ricos com potencial para integra√ß√£o com tecnologias modernas de IoT e automa√ß√£o.


New file: src/CDS/src/create_pipeline_views.sql
-- Cria√ß√£o de views para an√°lises espec√≠ficas

-- View para an√°lise de tend√™ncia de consumo mensal
CREATE VIEW vw_tendencia_consumo_mensal AS
SELECT 
    dt.ano,
    dt.mes,
    dl.uf,
    dl.sistema,
    SUM(fc.consumo_mwh) as consumo_total,
    SUM(fc.numero_consumidores) as total_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dt.mes, dl.uf, dl.sistema
ORDER BY dt.ano, dt.mes;

-- View para c√°lculo do consumo per capita por UF
CREATE VIEW vw_consumo_per_capita AS
SELECT 
    dt.ano,
    dl.uf,
    SUM(fc.consumo_mwh) as consumo_total,
    MAX(dl.populacao) as populacao,
    ROUND(SUM(fc.consumo_mwh) / MAX(dl.populacao), 2) as consumo_per_capita
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, dl.uf
ORDER BY dt.ano, dl.uf;

-- View para an√°lise de demanda por setor econ√¥mico
CREATE VIEW vw_demanda_setor AS
SELECT 
    dt.ano,
    ds.setor_n1,
    ds.setor_n2,
    dl.regiao,
    SUM(fc.consumo_mwh) as consumo_total,
    COUNT(DISTINCT fc.id_consumidor) as num_consumidores
FROM FATO_CONSUMO fc
JOIN DIM_TEMPO dt ON fc.data = dt.data
JOIN DIM_SETOR ds ON fc.id_setor = ds.id_setor
JOIN DIM_LOCALIZACAO dl ON fc.id_localizacao = dl.id_localizacao
GROUP BY dt.ano, ds.setor_n1, ds.setor_n2, dl.regiao
ORDER BY dt.ano, consumo_total DESC;

New file: src/CDS/src/initialize_database.sql
-- Cria√ß√£o das tabelas dimensionais
CREATE TABLE DIM_TEMPO (
    data DATE PRIMARY KEY,
    ano INT,
    mes INT,
    trimestre INT,
    mes_nome VARCHAR(20),
    CONSTRAINT chk_mes CHECK (mes BETWEEN 1 AND 12),
    CONSTRAINT chk_trimestre CHECK (trimestre BETWEEN 1 AND 4)
);

CREATE TABLE DIM_LOCALIZACAO (
    id_localizacao SERIAL PRIMARY KEY,
    uf VARCHAR(2),
    sistema VARCHAR(50),
    regiao VARCHAR(20),
    populacao DECIMAL(12,2),
    CONSTRAINT chk_uf CHECK (uf ~ '^[A-Z]{2}$')
);

CREATE TABLE DIM_CONSUMIDOR (
    id_consumidor SERIAL PRIMARY KEY,
    tipo_consumidor VARCHAR(10),
    faixa_consumo_n1 VARCHAR(50),
    faixa_consumo_n2 VARCHAR(50),
    CONSTRAINT chk_tipo_consumidor CHECK (tipo_consumidor IN ('Cativo', 'Livre'))
);

CREATE TABLE DIM_TENSAO (
    id_tensao SERIAL PRIMARY KEY,
    tensao_n1 VARCHAR(50),
    tensao_n2 VARCHAR(50),
    tensao_n3 VARCHAR(50)
);

CREATE TABLE DIM_SETOR (
    id_setor SERIAL PRIMARY KEY,
    setor_n1 VARCHAR(50),
    setor_n2 VARCHAR(50),
    setor_n3 VARCHAR(50)
);

-- Cria√ß√£o da tabela fato
CREATE TABLE FATO_CONSUMO (
    id_consumo SERIAL PRIMARY KEY,
    data DATE,
    id_localizacao INT,
    id_consumidor INT,
    id_tensao INT,
    id_setor INT,
    consumo_mwh DECIMAL(12,2),
    numero_consumidores INT,
    FOREIGN KEY (data) REFERENCES DIM_TEMPO(data),
    FOREIGN KEY (id_localizacao) REFERENCES DIM_LOCALIZACAO(id_localizacao),
    FOREIGN KEY (id_consumidor) REFERENCES DIM_CONSUMIDOR(id_consumidor),
    FOREIGN KEY (id_tensao) REFERENCES DIM_TENSAO(id_tensao),
    FOREIGN KEY (id_setor) REFERENCES DIM_SETOR(id_setor)
);

-- √çndices para otimiza√ß√£o de consultas
CREATE INDEX idx_fato_consumo_data ON FATO_CONSUMO(data);
CREATE INDEX idx_fato_consumo_localizacao ON FATO_CONSUMO(id_localizacao);
CREATE INDEX idx_fato_consumo_setor ON FATO_CONSUMO(id_setor);

New file: src/AICSS/diagram.json
{
  "version": 1,
  "author": "Bruno Conterato",
  "editor": "wokwi",
  "parts": [
    { "type": "board-esp32-devkit-c-v4", "id": "esp", "top": 0, "left": 0, "attrs": {} },
    {
      "type": "wokwi-photoresistor-sensor",
      "id": "ldr1",
      "top": 233.6,
      "left": -248.8,
      "attrs": {}
    },
    {
      "type": "wokwi-pir-motion-sensor",
      "id": "pir1",
      "top": -72.8,
      "left": -208.98,
      "attrs": {}
    },
    { "type": "wokwi-gnd", "id": "gnd1", "top": 297.6, "left": -29.4, "attrs": {} },
    { "type": "wokwi-gnd", "id": "gnd2", "top": 96, "left": -163.8, "attrs": {} },
    {
      "type": "wokwi-led",
      "id": "led1",
      "top": 63.6,
      "left": -322.6,
      "attrs": { "color": "white" }
    },
    {
      "type": "wokwi-resistor",
      "id": "r1",
      "top": 147.95,
      "left": -297.6,
      "attrs": { "value": "1000" }
    },
    {
      "type": "wokwi-gnd",
      "id": "gnd3",
      "top": 135.8,
      "left": -212.8,
      "rotate": 270,
      "attrs": {}
    },
    {
      "type": "wokwi-photoresistor-sensor",
      "id": "ldr2",
      "top": 233.4,
      "left": 209.2,
      "rotate": 180,
      "attrs": {}
    },
    { "type": "wokwi-pir-motion-sensor", "id": "pir2", "top": -72.8, "left": 223.02, "attrs": {} },
    {
      "type": "wokwi-resistor",
      "id": "r2",
      "top": 157.55,
      "left": 364.8,
      "attrs": { "value": "1000" }
    },
    { "type": "wokwi-led", "id": "led2", "top": 82.8, "left": 426.2, "attrs": { "color": "red" } },
    { "type": "wokwi-gnd", "id": "gnd4", "top": 96, "left": 287.4, "attrs": {} },
    { "type": "wokwi-gnd", "id": "gnd5", "top": 316.8, "left": 162.6, "attrs": {} },
    { "type": "wokwi-gnd", "id": "gnd6", "top": 145, "left": 317.6, "rotate": 90, "attrs": {} }
  ],
  "connections": [
    [ "esp:TX", "$serialMonitor:RX", "", [] ],
    [ "esp:RX", "$serialMonitor:TX", "", [] ],
    [ "ldr1:VCC", "esp:5V", "red", [ "h0" ] ],
    [ "ldr1:GND", "gnd1:GND", "black", [ "h0" ] ],
    [ "ldr1:AO", "esp:12", "green", [ "h0" ] ],
    [ "pir1:GND", "gnd2:GND", "black", [ "v0" ] ],
    [ "pir1:OUT", "esp:34", "green", [ "v0" ] ],
    [ "pir1:VCC", "esp:5V", "red", [ "v0" ] ],
    [ "led1:C", "r1:1", "green", [ "v0" ] ],
    [ "led1:A", "esp:25", "green", [ "v0" ] ],
    [ "r1:2", "gnd3:GND", "green", [ "v0" ] ],
    [ "led2:C", "r2:2", "green", [ "v0" ] ],
    [ "r2:1", "gnd6:GND", "green", [ "v0", "h-28.8" ] ],
    [ "pir2:GND", "gnd4:GND", "black", [ "v0" ] ],
    [ "ldr2:GND", "gnd5:GND", "black", [ "h0" ] ],
    [ "ldr2:VCC", "esp:5V", "red", [ "h0" ] ],
    [ "pir2:VCC", "esp:5V", "red", [ "v0" ] ],
    [ "led2:A", "esp:19", "green", [ "v0" ] ],
    [ "pir2:OUT", "esp:18", "green", [ "v0" ] ],
    [ "ldr2:AO", "esp:35", "green", [ "h0" ] ]
  ],
  "dependencies": {}
}

New file: src/AICSS/wokwi-project.txt
Downloaded from https://wokwi.com/projects/414960070191040513

Simulate this project on https://wokwi.com


New file: src/AICSS/platformio.ini
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:esp32]
platform = espressif32
framework = arduino
board = esp32dev

New file: src/AICSS/wokwi.toml
[wokwi]
version = 1
elf = ".pio/build/esp32/firmware.elf"
firmware = ".pio/build/esp32/firmware.bin"

# Forward http://localhost:8180 to port 80 on the simulated ESP32:
[[net.forward]]
from = "localhost:8180"
to = "target:80"

New file: src/AICSS/src/sketch.ino
// Pinos dos sensores e LED para o ambiente externo
const int LDR_EXTERNAL_PIN = 12;      // Pino para leitura do LDR (A0)
const int PIR_EXTERNAL_PIN = 34;      // Pino de entrada do sensor PIR (digital)
const int LED_EXTERNAL_PIN = 25;      // Pino de sa√≠da para controle do LED externo

// Pinos dos sensores e LED para o ambiente interno
const int LDR_INTERNAL_PIN = 35;      // Pino para leitura do LDR interno (A1)
const int PIR_INTERNAL_PIN = 18;      // Pino de entrada do sensor de presen√ßa interno (digital)
const int LED_INTERNAL_PIN = 19;      // Pino de sa√≠da para controle do LED interno

// Limiar de luminosidade (lux) para definir dia ou noite
const int LUMINOSITY_EXTERNAL_THRESHOLD = 10;  // Limiar para ilumina√ß√£o externa
const int LUMINOSITY_INTERNAL_THRESHOLD = 50;  // Limiar para ilumina√ß√£o interna

// LDR resistance at 10 lux e valor do Gamma (usados para ambos os ambientes)
const double rl10 = 50000.0; // LDR resistance at 10 lux
const double ldrGamma = 0.7;  // Gamma para o LDR

const unsigned long MOTION_EXTERNAL_DURATION = 30000; // Dura√ß√£o da ilumina√ß√£o m√°xima (30 segundos)
long motionExternalStartTime = -MOTION_EXTERNAL_DURATION;   // Momento em que o movimento foi detectado no externo

// Par√¢metros do LED interno
const int LED_INTERNAL_BRIGHTNESS = 255; // Brilho m√°ximo do LED interno

void setup() {
  setupExternal();
  setupInternal();
}

void loop() {
  loopExternal();
  loopInternal();
}

// ---------------------- Comum aos ambientes interno e externo ---------------------- //

bool isNight(double luminosity, int threshold) {
  return luminosity < threshold;
}

double calculateResistance(int ldr_value) {
  double voltage_ratio = ldr_value / (4095.0 - ldr_value);
  return 10000.0 * voltage_ratio;
}

double calculateLux(double resistance, double rl10, double gamma) {
  return 10.0 * pow(rl10 / resistance, 1.0 / gamma);
}

double readLuminosity(int ldr_pin, double rl10, double gamma) {
  int value = analogRead(ldr_pin);
  double resistance = calculateResistance(value);
  return calculateLux(resistance, rl10, gamma);
}

bool readMotion(int pir_pin) {
  return digitalRead(pir_pin) == HIGH;
}

// ---------------------- Ambiente Externo ---------------------- //
void setupExternal() {
  pinMode(PIR_EXTERNAL_PIN, INPUT);
  pinMode(LED_EXTERNAL_PIN, OUTPUT);

  // Inicializa√ß√£o da serial para monitoramento
  Serial.begin(115200);
}

void loopExternal() {
  // Leitura da luminosidade e detec√ß√£o de movimento no externo
  double luminosityExternal = readLuminosity(LDR_EXTERNAL_PIN, rl10, ldrGamma);
  bool motionDetectedExternal = readMotion(PIR_EXTERNAL_PIN);

  // Log para monitoramento
  Serial.print("Luminosity (External): ");
  Serial.print(luminosityExternal);
  Serial.print(" | Night status (External): ");
  Serial.println(isNight(luminosityExternal, LUMINOSITY_EXTERNAL_THRESHOLD) ? "Night" : "Day");
  Serial.print("Motion detected (External): ");
  Serial.println(motionDetectedExternal ? "Yes" : "No");

  // Controle da ilumina√ß√£o externa
  controlLightingExternal(luminosityExternal, motionDetectedExternal);
  Serial.println();

  delay(100); // Intervalo curto para leitura cont√≠nua
}

// Fun√ß√£o de controle de ilumina√ß√£o espec√≠fica para o ambiente externo
void controlLightingExternal(double luminosity, bool motionDetected) {
  bool night = isNight(luminosity, LUMINOSITY_EXTERNAL_THRESHOLD);
  unsigned long currentTime = millis();

  if (night) {
    if (motionDetected) {
      analogWrite(LED_EXTERNAL_PIN, 255);
      motionExternalStartTime = currentTime;
    } else if (currentTime - motionExternalStartTime < MOTION_EXTERNAL_DURATION) {
      analogWrite(LED_EXTERNAL_PIN, 255);
    } else {
      analogWrite(LED_EXTERNAL_PIN, 50);
    }
  } else {
    analogWrite(LED_EXTERNAL_PIN, 0);
  }
}

// ---------------------- Ambiente Interno ---------------------- //
void setupInternal() {
  pinMode(PIR_INTERNAL_PIN, INPUT);
  pinMode(LED_INTERNAL_PIN, OUTPUT);
}

void loopInternal() {
  // Leitura da luminosidade e detec√ß√£o de movimento no interno
  double luminosityInternal = readLuminosity(LDR_INTERNAL_PIN, rl10, ldrGamma);
  bool motionDetectedInternal = readMotion(PIR_INTERNAL_PIN);

  // Log para monitoramento
  Serial.print("Luminosity (Internal): ");
  Serial.print(luminosityInternal);
  Serial.print(" | Insufficient light: ");
  Serial.println(isNight(luminosityInternal, LUMINOSITY_INTERNAL_THRESHOLD) ? "Yes" : "No");
  Serial.print("Motion detected (Internal): ");
  Serial.println(motionDetectedInternal ? "Yes" : "No");

  // Controle da ilumina√ß√£o interna
  controlLightingInternal(luminosityInternal, motionDetectedInternal);
  Serial.println();

  delay(5000); // Intervalo curto para leitura cont√≠nua
}

void controlLightingInternal(double luminosity, bool motionDetected) {
  bool insufficientLight = isNight(luminosity, LUMINOSITY_INTERNAL_THRESHOLD);

  if (insufficientLight && motionDetected) {
    analogWrite(LED_INTERNAL_PIN, LED_INTERNAL_BRIGHTNESS);
    Serial.println("Internal: Insufficient light, motion detected. Lights ON.");
  } else {
    analogWrite(LED_INTERNAL_PIN, 0);
    Serial.println("Internal: Sufficient light or no motion. Lights OFF.");
  }
}


New file: src/AICSS/docs/report_external_illumination_system.md
## Relat√≥rio: Sistema de Ilumina√ß√£o Externa Inteligente

**Objetivo:** Desenvolver um sistema de ilumina√ß√£o externa que otimize o consumo de energia, garantindo a seguran√ßa atrav√©s de ilumina√ß√£o m√≠nima √† noite e acionando ilumina√ß√£o m√°xima apenas quando necess√°rio, baseado na detec√ß√£o de movimento.

**L√≥gica de Funcionamento:**

O sistema utiliza um sensor de luminosidade (LDR) e um sensor de movimento (simulado por um sensor gen√©rico de presen√ßa no Wokwi, considerando as limita√ß√µes do simulador) para controlar a intensidade da ilumina√ß√£o externa (simulada por um LED). A l√≥gica de opera√ß√£o √© a seguinte:
    
1. **Leitura da Luminosidade:** O ESP32 l√™ continuamente o valor fornecido pelo sensor LDR. Este valor representa a intensidade da luz ambiente.

2. **Determina√ß√£o do Per√≠odo (Dia/Noite):** O sistema compara o valor da luminosidade com um limiar pr√©-definido.  Se o valor estiver acima do limiar, considera-se dia. Abaixo do limiar, considera-se noite.

3. **Controle da Ilumina√ß√£o (Dia):** Durante o dia, independente da detec√ß√£o de movimento, a ilumina√ß√£o externa permanece desligada (LED OFF).

4. **Controle da Ilumina√ß√£o (Noite - Sem Movimento):** Durante a noite, na aus√™ncia de detec√ß√£o de movimento pelo sensor, a ilumina√ß√£o externa permanece em n√≠vel m√≠nimo (LED com brilho reduzido, ou simula√ß√£o atrav√©s de PWM com baixo ciclo de trabalho).

5. **Controle da Ilumina√ß√£o (Noite - Com Movimento):**  Durante a noite, se o sensor de movimento detectar movimento, a ilumina√ß√£o externa √© acionada em n√≠vel m√°ximo (LED ON com brilho m√°ximo, ou PWM com alto ciclo de trabalho) por um per√≠odo de 30 segundos. Ap√≥s os 30 segundos, o sistema retorna ao n√≠vel m√≠nimo de ilumina√ß√£o noturna (item 4), a menos que um novo movimento seja detectado antes do t√©rmino desse per√≠odo.  Um temporizador √© utilizado para controlar este per√≠odo de 30 segundos.

**Sensores Utilizados:**

* **Sensor de Luminosidade (LDR):**  Um resistor dependente da luz (LDR) que varia sua resist√™ncia de acordo com a intensidade da luz incidente.  O ESP32 mede a resist√™ncia para determinar o n√≠vel de luminosidade.

* **Sensor de Movimento (Simulado):** No Wokwi, um sensor digital gen√©rico que simula a detec√ß√£o de movimento.  Um sinal HIGH indica presen√ßa de movimento, enquanto um sinal LOW indica aus√™ncia.  Alternativamente, pode-se utilizar um bot√£o como um simulador muito simplificado.


**Componentes do Circuito (Wokwi):**

* 1 x ESP32
* 1 x LDR
* 1 x Sensor Digital (simulando sensor de movimento) ou 1 x Bot√£o (Simula√ß√£o simplificada)
* 1 x LED (Simulando a luz externa)
* Resistores de pull-up/pull-down (conforme necess√°rio para o sensor e o LED)


**Considera√ß√µes Adicionais:**

* **Calibra√ß√£o do Limiar de Luminosidade:** O limiar para distinguir dia e noite precisa ser calibrado para o ambiente espec√≠fico.
* **Ajustes de Brilho do LED:**  A intensidade m√≠nima e m√°xima do LED pode ser ajustada atrav√©s de PWM (Pulse Width Modulation) para controlar o brilho.  No Wokwi, pode-se simular com diferentes n√≠veis de luminosidade do LED.
* **Tratamento de Ru√≠do:**  √â importante implementar mecanismos para filtrar ru√≠dos ou falsas leituras dos sensores.  No caso do sensor de movimento, um per√≠odo m√≠nimo de tempo entre detec√ß√µes pode ser definido para evitar acionamentos repetidos por pequenas vibra√ß√µes.

Este relat√≥rio descreve o funcionamento do sistema de ilumina√ß√£o externa. A implementa√ß√£o no Wokwi necessitar√° de um c√≥digo adequado em linguagem C/C++ para o ESP32, que execute a l√≥gica descrita acima.  A simula√ß√£o no Wokwi permitir√° validar a funcionalidade do sistema antes de uma implementa√ß√£o f√≠sica.


New file: src/AICSS/docs/report_internal_illunination_system.md
## Relat√≥rio: Sistema de Ilumina√ß√£o Interna Inteligente

**Objetivo:** Desenvolver um sistema de ilumina√ß√£o interna que otimize o consumo de energia, acionando a luz apenas quando necess√°rio: em ambientes com luminosidade insuficiente e com detec√ß√£o de presen√ßa.

**L√≥gica de Funcionamento:**

O sistema utiliza um sensor de luminosidade (LDR) e um sensor de presen√ßa (simulado por um sensor gen√©rico de presen√ßa no Wokwi, ou por um bot√£o como simplifica√ß√£o) para controlar a intensidade da ilumina√ß√£o interna (simulada por um LED). A l√≥gica de opera√ß√£o √© a seguinte:

1. **Leitura da Luminosidade:** O ESP32 l√™ continuamente o valor fornecido pelo sensor LDR. Este valor representa a intensidade da luz ambiente.

2. **Determina√ß√£o do N√≠vel de Luminosidade:** O sistema compara o valor da luminosidade com um limiar pr√©-definido.  Se o valor estiver acima do limiar, considera-se luminosidade suficiente. Abaixo do limiar, considera-se luminosidade insuficiente.

3. **Detec√ß√£o de Presen√ßa:** O ESP32 l√™ o estado do sensor de presen√ßa. Um sinal HIGH indica presen√ßa, enquanto um sinal LOW indica aus√™ncia.

4. **Controle da Ilumina√ß√£o:**

    * **Luminosidade Suficiente:** Independente do estado do sensor de presen√ßa, se a luminosidade for suficiente, a ilumina√ß√£o interna permanece desligada (LED OFF).

    * **Luminosidade Insuficiente e Presen√ßa Detectado:** Se a luminosidade for insuficiente E o sensor de presen√ßa detectar presen√ßa, a ilumina√ß√£o interna √© acionada (LED ON).

    * **Luminosidade Insuficiente e Aus√™ncia de Presen√ßa:** Se a luminosidade for insuficiente, MAS o sensor de presen√ßa N√ÉO detectar presen√ßa, a ilumina√ß√£o interna permanece desligada (LED OFF).


**Sensores Utilizados:**

* **Sensor de Luminosidade (LDR):** Um resistor dependente da luz (LDR) que varia sua resist√™ncia de acordo com a intensidade da luz incidente. O ESP32 mede a resist√™ncia para determinar o n√≠vel de luminosidade.

* **Sensor de Presen√ßa (Simulado):** No Wokwi, um sensor digital gen√©rico que simula a detec√ß√£o de presen√ßa. Um sinal HIGH indica presen√ßa, enquanto um sinal LOW indica aus√™ncia. Alternativamente, pode-se utilizar um bot√£o como um simulador muito simplificado.


**Componentes do Circuito (Wokwi):**

* 1 x ESP32
* 1 x LDR
* 1 x Sensor Digital (simulando sensor de presen√ßa) ou 1 x Bot√£o (Simula√ß√£o simplificada)
* 1 x LED (Simulando a luz interna)
* Resistores de pull-up/pull-down (conforme necess√°rio para o sensor e o LED)


**Considera√ß√µes Adicionais:**

* **Calibra√ß√£o do Limiar de Luminosidade:** O limiar para distinguir luminosidade suficiente e insuficiente precisa ser calibrado para o ambiente espec√≠fico.
* **Tratamento de Ru√≠do:** √â importante implementar mecanismos para filtrar ru√≠dos ou falsas leituras dos sensores, principalmente do sensor de presen√ßa.  Um per√≠odo m√≠nimo de tempo entre detec√ß√µes ou uma contagem de m√∫ltiplas detec√ß√µes podem ser considerados para evitar acionamentos falsos.
* **Tipo de L√¢mpada:**  A escolha do tipo de l√¢mpada (e sua pot√™ncia) afetar√° diretamente o consumo de energia. L√¢mpadas LED s√£o mais eficientes em termos de energia do que as l√¢mpadas incandescentes ou fluorescentes.


Este relat√≥rio descreve o funcionamento do sistema de ilumina√ß√£o interna. A implementa√ß√£o no Wokwi necessitar√° de um c√≥digo adequado em linguagem C/C++ para o ESP32, que execute a l√≥gica descrita acima. A simula√ß√£o no Wokwi permitir√° validar a funcionalidade do sistema antes de uma implementa√ß√£o f√≠sica.


New file: src/AICSS/docs/other/sensor_diagram.md
### Diagrama de Circuito para Otimiza√ß√£o de Ilumina√ß√£o Residencial

O diagrama Wokwi descreve um circuito que simula a otimiza√ß√£o da ilumina√ß√£o interna e externa de uma resid√™ncia utilizando sensores LDR (Fotoresistor) e PIR (Sensor de Movimento) com o microcontrolador ESP32. A solu√ß√£o considera a luminosidade e o movimento para acionar os LEDs e garantir que a ilumina√ß√£o externa nunca fique totalmente apagada durante a noite, visando seguran√ßa.

### Fun√ß√µes dos Componentes:

#### Ambiente Externo
- **LDR Externo (LDR1)**: Mede a luminosidade externa e determina se est√° noite ou dia, utilizando a resist√™ncia do LDR.
- **Sensor PIR Externo (PIR1)**: Detecta movimentos externos e ativa a ilumina√ß√£o quando h√° movimento durante a noite.
- **LED Externo (LED1)**: Representa a ilumina√ß√£o externa, que pode ser acesa durante a noite ou quando h√° movimento.

#### Ambiente Interno
- **LDR Interno (LDR2)**: Mede a luminosidade interna, ativando as luzes internas quando a luz ambiente for insuficiente.
- **Sensor PIR Interno (PIR2)**: Detecta movimento interno e aciona a ilumina√ß√£o interna.
- **LED Interno (LED2)**: Representa a ilumina√ß√£o interna, que √© ajustada conforme a luminosidade e o movimento detectado.

### Conex√µes dos Componentes:

#### Ambiente Externo:
1. **LDR Externo (LDR1)**:
   - **VCC** ‚Üí **5V** do ESP32
   - **GND** ‚Üí **GND** do ESP32
   - **AO (Sa√≠da Anal√≥gica)** ‚Üí **Pino 12** do ESP32

2. **Sensor PIR Externo (PIR1)**:
   - **VCC** ‚Üí **5V** do ESP32
   - **GND** ‚Üí **GND** do ESP32
   - **OUT** ‚Üí **Pino 34** do ESP32

3. **LED Externo (LED1)**:
   - **A** ‚Üí **Pino 25** do ESP32
   - **C** ‚Üí **Resistor de 1kŒ© (R1)** ‚Üí **GND**

#### Ambiente Interno:
1. **LDR Interno (LDR2)**:
   - **VCC** ‚Üí **5V** do ESP32
   - **GND** ‚Üí **GND** do ESP32
   - **AO (Sa√≠da Anal√≥gica)** ‚Üí **Pino 35** do ESP32

2. **Sensor PIR Interno (PIR2)**:
   - **VCC** ‚Üí **5V** do ESP32
   - **GND** ‚Üí **GND** do ESP32
   - **OUT** ‚Üí **Pino 18** do ESP32

3. **LED Interno (LED2)**:
   - **A** ‚Üí **Pino 19** do ESP32
   - **C** ‚Üí **Resistor de 1kŒ© (R2)** ‚Üí **GND**

### Funcionamento:

1. **Ambiente Externo**:
   - O LDR externo detecta a luminosidade e, se estiver abaixo de um determinado limiar, o sistema considera que √© noite.
   - O sensor PIR externo detecta movimento. Se houver movimento e estiver √† noite, o LED externo ser√° acionado.
   - Se n√£o houver movimento, o LED externo permanece aceso por 30 segundos e depois diminui a intensidade para garantir seguran√ßa, mas sem consumir energia excessiva.

2. **Ambiente Interno**:
   - O LDR interno mede a luminosidade e, se a luz estiver abaixo de um limiar, o sistema acende as luzes internas.
   - O sensor PIR interno detecta movimento. Se houver movimento e a luminosidade estiver baixa, o LED interno ser√° aceso.
   - Caso contr√°rio, o LED interno √© apagado para economizar energia.

### C√≥digo de Controle:

O c√≥digo realiza a leitura da luminosidade e do movimento em ambos os ambientes e controla os LEDs de acordo com a detec√ß√£o de luz e movimento. No ambiente externo, as luzes permanecem acesas por um per√≠odo ap√≥s o movimento ser detectado, enquanto no ambiente interno, as luzes s√£o ajustadas conforme a necessidade de ilumina√ß√£o.


Esse diagrama e descri√ß√£o formam um sistema que n√£o apenas otimiza a ilumina√ß√£o, mas tamb√©m oferece seguran√ßa ao garantir que a ilumina√ß√£o externa n√£o seja desligada completamente durante a noite.

![Diagrama de Circuito](../../../assets/sensors_diagram.png)

New file: src/AICSS/docs/other/cost_estimation_external_illunination_system.md
## Estimativa de Economia de Energia com o Sistema de Ilumina√ß√£o Inteligente

Esta estimativa considera uma √∫nica l√¢mpada externa e um m√™s com 30 dias.  Precisamos fazer algumas suposi√ß√µes razo√°veis, pois dados precisos sobre o consumo e o tempo de funcionamento dependem de fatores espec√≠ficos como o tipo de l√¢mpada, o seu consumo de pot√™ncia e a frequ√™ncia de detec√ß√£o de movimento.

**Suposi√ß√µes:**

* **L√¢mpada:**  L√¢mpada LED de 10W.
* **Ilumina√ß√£o M√°xima (Sem Sistema):** A l√¢mpada permanece ligada durante toda a noite (consideremos 12 horas por noite).
* **Ilumina√ß√£o M√≠nima (Com Sistema):**  A l√¢mpada opera a 1W (10% da pot√™ncia m√°xima) durante a noite, na aus√™ncia de movimento.
* **Ilumina√ß√£o M√°xima (Com Sistema):**  A l√¢mpada opera a 10W por 30 segundos a cada 5 minutos em m√©dia (uma detec√ß√£o de movimento a cada 5 minutos, o que √© uma estimativa conservadora).
* **Consumo ESP32:** O consumo do ESP32 √© desprez√≠vel em compara√ß√£o com o consumo da l√¢mpada, considerando-se que o consumo energ√©tico do ESP32 √© menor que 1W. Por esta raz√£o, o consumo do ESP32 n√£o ser√° inclu√≠do no c√°lculo.
* **Custo da Energia:** R$ 0,74593/kWh.

![Custo da Energia (acesso em 19/11/2024)](../../../assets/equatorial_cost_19_11_2024.png)
Custo da Energia. Fonte: <https://go.equatorialenergia.com.br/valor-de-tarifas-e-servicos/#residencial-normal> (Equatorial em Goi√°s - cesso em 19/11/2024)

**C√°lculos:**

**1. Sem o Sistema Proposto:**

* **Consumo Di√°rio:** 10W * 12h/dia = 120 Wh/dia
* **Consumo Mensal:** 120 Wh/dia * 30 dias = 3600 Wh = 3.6 kWh
* **Custo Mensal:** 3.6 kWh * R$ 0,74593/kWh = R$ 2.685348


**2. Com o Sistema Proposto:**

* **Consumo de Ilumina√ß√£o M√≠nima por Dia:** 1W * 12h/dia = 12 Wh/dia
* **Consumo de Ilumina√ß√£o M√°xima por Dia:** (10W * 30s/300s) * 12h/dia ‚âà 12 Wh/dia  (considerando a ativa√ß√£o a cada 5 minutos, o que representa 12 ativa√ß√µes por hora)
* **Consumo Total Di√°rio (Com Sistema):** 12 Wh/dia + 12 Wh/dia = 24 Wh/dia
* **Consumo Mensal (Com Sistema):** 24 Wh/dia * 30 dias = 720 Wh = 0.72 kWh
* **Custo Mensal (Com Sistema):** 0.72 kWh * R$ 0,74593/kWh = R$ 0.5370816


**Economia:**

* **Economia Mensal:** R$ 2.685348 - R$ 0.5370816 = R$ 2.1482664

**Conclus√£o:**

Considerando as suposi√ß√µes feitas, a economia estimada por l√¢mpada com o sistema de ilumina√ß√£o inteligente ao longo de um m√™s √© de aproximadamente **R$ 2,15**.  √â importante ressaltar que esta √© uma estimativa e o valor real pode variar dependendo dos fatores n√£o considerados, como a frequ√™ncia real de ativa√ß√£o da ilumina√ß√£o m√°xima, o tipo de l√¢mpada utilizada, e o tempo real de inatividade da mesma. Para obter uma estimativa mais precisa, seria necess√°rio monitorar o consumo real do sistema em condi√ß√µes reais de opera√ß√£o durante um per√≠odo representativo.




New file: src/AICSS/docs/other/cost_estmation_internal_illumination_system.md
## Estimativa de Economia de Energia com o Sistema de Ilumina√ß√£o Interna Inteligente

Esta estimativa considera uma √∫nica l√¢mpada interna e um m√™s com 30 dias.  Novamente, precisaremos fazer algumas suposi√ß√µes razo√°veis, pois dados precisos dependem de fatores espec√≠ficos como o tipo de l√¢mpada, seu consumo de pot√™ncia, a luminosidade ambiente e a frequ√™ncia de ocupa√ß√£o do c√¥modo.

**Suposi√ß√µes:**

* **L√¢mpada:** L√¢mpada LED de 8W.
* **Ilumina√ß√£o M√°xima (Sem Sistema):** A l√¢mpada permanece ligada durante 8 horas por dia (cen√°rio base: ocupa√ß√£o m√©dia do c√¥modo).
* **Ilumina√ß√£o M√°xima (Com Sistema):** A l√¢mpada opera a 8W apenas quando a luminosidade √© insuficiente e h√° presen√ßa detectada.  Suponhamos que isto ocorra por 4 horas por dia, em m√©dia.
* **Consumo ESP32:** O consumo do ESP32 √© desprez√≠vel em compara√ß√£o com o consumo da l√¢mpada e ser√° ignorado.
* **Custo da Energia:** R$ 0,74593/kWh.


**C√°lculos:**

**1. Sem o Sistema Proposto:**

* **Consumo Di√°rio:** 8W * 8h/dia = 64 Wh/dia
* **Consumo Mensal:** 64 Wh/dia * 30 dias = 1920 Wh = 1.92 kWh
* **Custo Mensal:** 1.92 kWh * R$ 0,74593/kWh = R$ 1.4317056


**2. Com o Sistema Proposto:**

* **Consumo Di√°rio (Com Sistema):** 8W * 4h/dia = 32 Wh/dia
* **Consumo Mensal (Com Sistema):** 32 Wh/dia * 30 dias = 960 Wh = 0.96 kWh
* **Custo Mensal (Com Sistema):** 0.96 kWh * R$ 0,74593/kWh = R$ 0.7160928


**Economia:**

* **Economia Mensal:** R$ 1.4317056 - R$ 0.7160928 = R$ 0.7156128

**Conclus√£o:**

Considerando as suposi√ß√µes feitas, a economia estimada por l√¢mpada com o sistema de ilumina√ß√£o interna inteligente ao longo de um m√™s √© de aproximadamente **R$ 0,72**.  Novamente, esta √© uma estimativa e o valor real pode variar significativamente dependendo de fatores como a frequ√™ncia de uso do c√¥modo, a luminosidade ambiente e a sensibilidade do sensor de presen√ßa. Um monitoramento do consumo real em um ambiente real forneceria dados mais precisos.  Observe que esta estimativa considera uma ocupa√ß√£o do ambiente de 8 horas di√°rias sem o sistema, e de 4 horas com o sistema. Esta diferen√ßa deve-se √† l√≥gica do sistema que mant√©m a l√¢mpada desligada mesmo durante o per√≠odo de ocupa√ß√£o caso a luminosidade seja suficiente.  Assim, o resultado da estimativa depender√° de forma significativa das condi√ß√µes de ilumina√ß√£o ambiente.


New file: src/CTWP/README.md
# Sistema de Monitoramento de Energia Residencial

## Introdu√ß√£o

Este projeto foi desenvolvido como parte da atividade **Global Solutions (GS) 2024.2**, cujo tema √© **Energia**. A solu√ß√£o utiliza **Data Science**, **IoT**, **Python** e **Banco de Dados** para otimizar o consumo de energia em ambientes residenciais, com foco na efici√™ncia energ√©tica, sustentabilidade e redu√ß√£o de custos.

A aplica√ß√£o apresentada oferece uma interface gr√°fica para monitoramento e gerenciamento do consumo energ√©tico, integrando dispositivos residenciais e simulando dados em tempo real. A ideia √© proporcionar uma base funcional que pode ser expandida para incluir recursos avan√ßados, como integra√ß√£o com fontes renov√°veis (solar, e√≥lica) e an√°lise preditiva.

---

## Objetivos

- **Monitorar o consumo energ√©tico em tempo real:** Simular dispositivos e seu impacto no consumo total.
- **Promover efici√™ncia energ√©tica:** Apresentar dados que ajudam o usu√°rio a identificar padr√µes e reduzir custos.
- **Fornecer uma base escal√°vel:** Preparar o sistema para integra√ß√£o com banco de dados e fontes renov√°veis.
- **Estimar custos de energia:** Calcular o custo com base no consumo di√°rio e na tarifa energ√©tica.

---

## Funcionalidades do Sistema

### 1. Interface Gr√°fica
- Desenvolvida com **Tkinter**, apresentando um painel principal dividido em:
  - **Dispositivos:** Lista de dispositivos com status, pot√™ncia e consumo.
  - **Gr√°ficos:** Exibi√ß√£o do consumo energ√©tico em tempo real.
  - **Estat√≠sticas:** Dados de consumo atual, di√°rio e custo estimado.

### 2. Monitoramento em Tempo Real
- Atualiza√ß√µes autom√°ticas a cada 10 segundos.
- Consumo de dispositivos simulados com varia√ß√µes aleat√≥rias para refletir condi√ß√µes reais.

### 3. Gr√°ficos Interativos
- Exibi√ß√£o do hist√≥rico de consumo com timestamps.
- Representa√ß√£o visual clara e intuitiva para an√°lise do usu√°rio.

### 4. Estat√≠sticas de Consumo e Custo
- Consumo atual em watts (W).
- Consumo di√°rio estimado em kilowatt-hora (kWh).
- C√°lculo do custo com base na tarifa simulada (R$ 0,75/kWh).

---

## Detalhamento T√©cnico

### Tecnologias Utilizadas
- **Python 3.9+**
- **Tkinter:** Cria√ß√£o da interface gr√°fica.
- **Matplotlib:** Gr√°ficos interativos de consumo.
- **Pandas:** Manipula√ß√£o e an√°lise de dados (poss√≠vel expans√£o futura).
- **Random:** Simula√ß√£o de dados para dispositivos.

### Estrutura do C√≥digo
1. **Classe Principal (`EnergyMonitorSystem`):**
   - Gerencia dispositivos, consumo e atualiza√ß√£o dos dados.
   - Respons√°vel pela interface gr√°fica e integra√ß√£o dos componentes.
2. **Simula√ß√£o de Consumo:**
   - Estima o consumo de dispositivos com base no status atual (ligado/desligado) e uma varia√ß√£o aleat√≥ria.
3. **Atualiza√ß√£o Autom√°tica:**
   - Usa `root.after()` para atualizar os dados e gr√°ficos em intervalos regulares.

---

## Utilidade Pr√°tica

- **Resid√™ncias:** Monitoramento detalhado do consumo energ√©tico e identifica√ß√£o de dispositivos com alto consumo.
- **Educa√ß√£o:** Demonstra√ß√£o de conceitos de IoT e otimiza√ß√£o energ√©tica para estudantes e profissionais.
- **Base para Projetos Avan√ßados:** Escal√°vel para integra√ß√£o com fontes renov√°veis, banco de dados e dispositivos reais.

---

## Possibilidades de Expans√£o

### 1. Integra√ß√£o com Banco de Dados
- Armazenar hist√≥rico de consumo para an√°lises futuras.
- Salvar configura√ß√µes personalizadas de dispositivos.

### 2. Fontes de Energia Renov√°vel
- Monitorar gera√ß√£o solar e e√≥lica.
- Selecionar automaticamente a fonte mais econ√¥mica e sustent√°vel.

### 3. An√°lise Preditiva
- Usar algoritmos de machine learning para prever padr√µes de consumo.
- Detectar anomalias e sugerir a√ß√µes corretivas.

### 4. Relat√≥rios e Notifica√ß√µes
- Gerar relat√≥rios em PDF com estat√≠sticas detalhadas.
- Enviar notifica√ß√µes em tempo real (e-mail ou push).

### 5. Controle Autom√°tico
- Ativar/desativar dispositivos automaticamente com base em regras predefinidas (ex.: hor√°rios de pico).

---

## Como Usar

1. **Pr√©-requisitos:**
   - Python 3.9+ instalado.
   - Bibliotecas necess√°rias: `tkinter`, `matplotlib`, `pandas`.

2. **Execu√ß√£o:**
   - Clone este reposit√≥rio:
     ```bash
     git clone https://github.com/brunoconterato/fiap_global_solutions_2024
     cd fiap_global_solutions_2024/src/CTWP
     ```
   - Execute o script principal:
     ```bash
     python src/main.py
     ```

3. **Interface:**
   - Visualize os dispositivos e seu status.
   - Acompanhe o consumo em tempo real no gr√°fico.
   - Consulte as estat√≠sticas de consumo e custo estimado.

---

## Conclus√£o

Este projeto √© um ponto de partida para o desenvolvimento de sistemas inteligentes de monitoramento energ√©tico. Ele combina conceitos de programa√ß√£o, ci√™ncia de dados e IoT, com foco na sustentabilidade e efici√™ncia energ√©tica. A solu√ß√£o pode ser personalizada e expandida conforme as necessidades espec√≠ficas de diferentes cen√°rios residenciais, comerciais ou urbanos.

## Ap√™ndices

### A. Imagem da Interface Gr√°fica

![Interface Gr√°fica](./assets/interface.png)

### B. C√≥digo-fonte

```python
import tkinter as tk
from tkinter import ttk
import random
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pandas as pd

class EnergyMonitorSystem:
    def __init__(self, root):
        self.root = root
        self.root.title("Sistema de Monitoramento de Energia")
        self.root.geometry("1200x800")
        
        # Dados simulados
        self.devices = {
            "Ar Condicionado": {"power": 1400, "status": "OFF"},
            "Geladeira": {"power": 350, "status": "ON"},
            "Chuveiro": {"power": 5500, "status": "OFF"},
            "TV": {"power": 100, "status": "OFF"},
            "Ilumina√ß√£o": {"power": 200, "status": "ON"}
        }
        
        self.current_consumption = 0
        self.consumption_history = []
        self.timestamps = []
        
        self.setup_gui()
        self.update_data()

    def setup_gui(self):
        # Frame principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # T√≠tulo
        title = ttk.Label(main_frame, text="Monitoramento de Energia Residencial", 
                         font=('Helvetica', 16, 'bold'))
        title.grid(row=0, column=0, columnspan=2, pady=10)

        # Frame esquerdo - Dispositivos
        devices_frame = ttk.LabelFrame(main_frame, text="Dispositivos", padding="10")
        devices_frame.grid(row=1, column=0, padx=5, pady=5, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Lista de dispositivos
        for i, (device, info) in enumerate(self.devices.items()):
            ttk.Label(devices_frame, text=f"{device}:").grid(row=i, column=0, padx=5, pady=2)
            ttk.Label(devices_frame, text=f"{info['power']}W").grid(row=i, column=1, padx=5, pady=2)
            status_var = tk.StringVar(value=info['status'])
            ttk.Label(devices_frame, textvariable=status_var).grid(row=i, column=2, padx=5, pady=2)

        # Frame direito - Gr√°ficos
        graph_frame = ttk.LabelFrame(main_frame, text="Consumo em Tempo Real", padding="10")
        graph_frame.grid(row=1, column=1, padx=5, pady=5, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Criar figura do matplotlib
        self.fig, self.ax = plt.subplots(figsize=(8, 4))
        self.canvas = FigureCanvasTkAgg(self.fig, master=graph_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Frame inferior - Estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estat√≠sticas", padding="10")
        stats_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky=(tk.W, tk.E))

        # Labels para estat√≠sticas
        self.current_power_var = tk.StringVar(value="Consumo Atual: 0W")
        self.daily_consumption_var = tk.StringVar(value="Consumo Di√°rio: 0 kWh")
        self.cost_var = tk.StringVar(value="Custo Estimado: R$ 0,00")

        ttk.Label(stats_frame, textvariable=self.current_power_var).grid(row=0, column=0, padx=5)
        ttk.Label(stats_frame, textvariable=self.daily_consumption_var).grid(row=0, column=1, padx=5)
        ttk.Label(stats_frame, textvariable=self.cost_var).grid(row=0, column=2, padx=5)

    def simulate_consumption(self):
        """Simula o consumo de energia dos dispositivos"""
        total = 0
        for device, info in self.devices.items():
            if info['status'] == 'ON':
                # Adiciona alguma varia√ß√£o aleat√≥ria
                variation = random.uniform(0.8, 1.2)
                total += info['power'] * variation
        return total

    def update_data(self):
        """Atualiza os dados e gr√°ficos"""
        # Simular novo consumo
        self.current_consumption = self.simulate_consumption()
        self.consumption_history.append(self.current_consumption)
        self.timestamps.append(datetime.now())

        # Manter apenas os √∫ltimos 60 pontos (10 minutos)
        if len(self.consumption_history) > 60:
            self.consumption_history.pop(0)
            self.timestamps.pop(0)

        # Atualizar gr√°fico
        self.ax.clear()
        self.ax.plot(self.timestamps, self.consumption_history, 'b-')
        self.ax.set_xlabel('Tempo')
        self.ax.set_ylabel('Consumo (W)')
        self.ax.tick_params(axis='x', rotation=45)
        self.fig.tight_layout()
        self.canvas.draw()

        # Atualizar estat√≠sticas
        self.current_power_var.set(f"Consumo Atual: {self.current_consumption:.1f}W")
        daily_kwh = sum(self.consumption_history) * 10 / (3600 * 1000)  # convertendo para kWh
        self.daily_consumption_var.set(f"Consumo Di√°rio: {daily_kwh:.2f} kWh")
        cost = daily_kwh * 0.75  # Considerando tarifa de R$ 0,75 por kWh
        self.cost_var.set(f"Custo Estimado: R$ {cost:.2f}")

        # Simular mudan√ßa aleat√≥ria no status dos dispositivos
        for device in self.devices:
            if random.random() < 0.1:  # 10% de chance de mudar o status
                self.devices[device]['status'] = 'ON' if random.random() < 0.5 else 'OFF'

        # Agendar pr√≥xima atualiza√ß√£o
        self.root.after(10000, self.update_data)  # Atualiza a cada 10 segundos

if __name__ == "__main__":
    root = tk.Tk()
    app = EnergyMonitorSystem(root)
    root.mainloop()
```

New file: src/CTWP/src/main.py
import tkinter as tk
from tkinter import ttk
import random
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pandas as pd

class EnergyMonitorSystem:
    def __init__(self, root):
        self.root = root
        self.root.title("Sistema de Monitoramento de Energia")
        self.root.geometry("1200x800")
        
        # Dados simulados
        self.devices = {
            "Ar Condicionado": {"power": 1400, "status": "OFF"},
            "Geladeira": {"power": 350, "status": "ON"},
            "Chuveiro": {"power": 5500, "status": "OFF"},
            "TV": {"power": 100, "status": "OFF"},
            "Ilumina√ß√£o": {"power": 200, "status": "ON"}
        }
        
        self.current_consumption = 0
        self.consumption_history = []
        self.timestamps = []
        
        self.setup_gui()
        self.update_data()

    def setup_gui(self):
        # Frame principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # T√≠tulo
        title = ttk.Label(main_frame, text="Monitoramento de Energia Residencial", 
                         font=('Helvetica', 16, 'bold'))
        title.grid(row=0, column=0, columnspan=2, pady=10)

        # Frame esquerdo - Dispositivos
        devices_frame = ttk.LabelFrame(main_frame, text="Dispositivos", padding="10")
        devices_frame.grid(row=1, column=0, padx=5, pady=5, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Lista de dispositivos
        for i, (device, info) in enumerate(self.devices.items()):
            ttk.Label(devices_frame, text=f"{device}:").grid(row=i, column=0, padx=5, pady=2)
            ttk.Label(devices_frame, text=f"{info['power']}W").grid(row=i, column=1, padx=5, pady=2)
            status_var = tk.StringVar(value=info['status'])
            ttk.Label(devices_frame, textvariable=status_var).grid(row=i, column=2, padx=5, pady=2)

        # Frame direito - Gr√°ficos
        graph_frame = ttk.LabelFrame(main_frame, text="Consumo em Tempo Real", padding="10")
        graph_frame.grid(row=1, column=1, padx=5, pady=5, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Criar figura do matplotlib
        self.fig, self.ax = plt.subplots(figsize=(8, 4))
        self.canvas = FigureCanvasTkAgg(self.fig, master=graph_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Frame inferior - Estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estat√≠sticas", padding="10")
        stats_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky=(tk.W, tk.E))

        # Labels para estat√≠sticas
        self.current_power_var = tk.StringVar(value="Consumo Atual: 0W")
        self.daily_consumption_var = tk.StringVar(value="Consumo Di√°rio: 0 kWh")
        self.cost_var = tk.StringVar(value="Custo Estimado: R$ 0,00")

        ttk.Label(stats_frame, textvariable=self.current_power_var).grid(row=0, column=0, padx=5)
        ttk.Label(stats_frame, textvariable=self.daily_consumption_var).grid(row=0, column=1, padx=5)
        ttk.Label(stats_frame, textvariable=self.cost_var).grid(row=0, column=2, padx=5)

    def simulate_consumption(self):
        """Simula o consumo de energia dos dispositivos"""
        total = 0
        for device, info in self.devices.items():
            if info['status'] == 'ON':
                # Adiciona alguma varia√ß√£o aleat√≥ria
                variation = random.uniform(0.8, 1.2)
                total += info['power'] * variation
        return total

    def update_data(self):
        """Atualiza os dados e gr√°ficos"""
        # Simular novo consumo
        self.current_consumption = self.simulate_consumption()
        self.consumption_history.append(self.current_consumption)
        self.timestamps.append(datetime.now())

        # Manter apenas os √∫ltimos 60 pontos (10 minutos)
        if len(self.consumption_history) > 60:
            self.consumption_history.pop(0)
            self.timestamps.pop(0)

        # Atualizar gr√°fico
        self.ax.clear()
        self.ax.plot(self.timestamps, self.consumption_history, 'b-')
        self.ax.set_xlabel('Tempo')
        self.ax.set_ylabel('Consumo (W)')
        self.ax.tick_params(axis='x', rotation=45)
        self.fig.tight_layout()
        self.canvas.draw()

        # Atualizar estat√≠sticas
        self.current_power_var.set(f"Consumo Atual: {self.current_consumption:.1f}W")
        daily_kwh = sum(self.consumption_history) * 10 / (3600 * 1000)  # convertendo para kWh
        self.daily_consumption_var.set(f"Consumo Di√°rio: {daily_kwh:.2f} kWh")
        cost = daily_kwh * 0.75  # Considerando tarifa de R$ 0,75 por kWh
        self.cost_var.set(f"Custo Estimado: R$ {cost:.2f}")

        # Simular mudan√ßa aleat√≥ria no status dos dispositivos
        for device in self.devices:
            if random.random() < 0.1:  # 10% de chance de mudar o status
                self.devices[device]['status'] = 'ON' if random.random() < 0.5 else 'OFF'

        # Agendar pr√≥xima atualiza√ß√£o
        self.root.after(10000, self.update_data)  # Atualiza a cada 10 segundos

if __name__ == "__main__":
    root = tk.Tk()
    app = EnergyMonitorSystem(root)
    root.mainloop()

New file: src/SCR/src/eda.R
#############################################
##### 1. Definindo Objetivos da An√°lise #####
#############################################

# Objetivos da an√°lise explorat√≥ria de dados:

# 1. Insights sobre estrat√©gias eficazes: Identificar as tipologias de projetos de efici√™ncia
#    energ√©tica que apresentaram maior retorno sobre o investimento (ROI) e maior redu√ß√£o
#    na demanda de energia.  Analisar a rela√ß√£o entre a metodologia utilizada e a efic√°cia
#    do projeto.

# 2. Identifica√ß√£o de lacunas:  Detectar poss√≠veis lacunas no programa de efici√™ncia
#    energ√©tica, analisando a distribui√ß√£o das tipologias de projetos, usos finais da energia
#    e regi√µes geogr√°ficas (embora essa √∫ltima informa√ß√£o n√£o esteja dispon√≠vel diretamente
#    nesse dataset).  Identificar se h√° desequil√≠brio na aloca√ß√£o de recursos para diferentes
#    tipos de projetos ou usos finais.


####################################################
##### 2. Carregando as bibliotecas necess√°rias #####
####################################################

# Carregando as bibliotecas necess√°rias
library(dplyr)
library(tidyr)
library(ggplot2)
library(DescTools)
library(car)
library(mice)
library(GGally)

# Importando os dados (substitua "seu_arquivo.csv" pelo nome do seu arquivo)
dados <- read.csv("/home/bruno/Workspace/FIAP/2024/Fase_4/fiap_global_solutions_2024/src/SCR/data/e12d5430-f747-4fc7-b620-2460ed02cc17.csv", sep = ",", dec = ".", header = TRUE, na.strings = c("", "NA", " "))


# Descri√ß√£o do conjunto de dados:
# Este conjunto de dados apresenta informa√ß√µes sobre projetos de efici√™ncia energ√©tica promovidos
# pelo Programa de Efici√™ncia Energ√©tica, regulamentado pela Resolu√ß√£o Normativa ANEEL n¬∫ 300/2008.

# Inclui dados por distribuidora, tipologia de projeto, demanda reduzida, energia economizada
# (GWh/ano) e investimentos em usos finais da energia.

# O objetivo √© demonstrar a viabilidade e os benef√≠cios econ√¥micos de melhorias em efici√™ncia energ√©tica,
# promovendo a transforma√ß√£o do mercado e incentivando novas tecnologias e pr√°ticas racionais
# no uso de energia el√©trica.

# Os dados s√£o atualizados mensalmente e est√£o dispon√≠veis em formatos como CSV.

# Os dados podem ser acessados pelo Link:
# https://dadosabertos.aneel.gov.br/dataset/projetos-de-eficiencia-energetica

# Descri√ß√£o das colunas:

# DatGeracaoConjuntoDados: Data de processamento dos dados (ex.: "2023-03-30"). Indica quando
# os dados foram atualizados e publicados no formato aberto. Unidade: Data (YYYY-MM-DD).

# NomAgente: Nome da empresa respons√°vel pelo projeto (ex.: "EletroDistribuidora S.A.").
# Identifica juridicamente a organiza√ß√£o que prop√¥s ou executou o projeto. Unidade: Texto.

# IdeEmpresaProponenteProjeto: C√≥digo num√©rico √∫nico da empresa (ex.: 12345). Utilizado para
# identificar a proponente na base de dados. Unidade: N√∫mero.

# DscTituloProjeto: T√≠tulo do projeto (ex.: "Redu√ß√£o de Consumo em Ilumina√ß√£o P√∫blica").
# Resumo do objetivo principal do projeto. Unidade: Texto.

# DscStatusProjeto: Status atual do projeto (ex.: "Conclu√≠do", "Em andamento"). Informa o
# andamento do projeto em rela√ß√£o ao planejamento. Unidade: Texto.

# DscTipologia: Tipo de projeto de efici√™ncia energ√©tica (ex.: "Ilumina√ß√£o P√∫blica"). Indica
# a √°rea de aplica√ß√£o ou foco do projeto. Unidade: Texto.

# DscUsoFinal: Uso final da energia impactado pelo projeto (ex.: "Aquecimento", "Refrigera√ß√£o").
# Representa onde a economia de energia foi aplicada. Unidade: Texto.

# VlrBeneficioEnergiaEconomizada: Energia economizada anualmente (ex.: 12.34). Indica o total de
# energia reduzido com o projeto. Unidade: GWh/ano.

# VlrRcb: Valor do retorno sobre o custo-benef√≠cio do projeto (ex.: 1.75). Mede a rela√ß√£o entre
# os benef√≠cios obtidos e os custos investidos. Unidade: Valor monet√°rio.

# VlrDemandaReduzidaPonta: Redu√ß√£o da demanda de energia no pico (ex.: 1000.50). Mostra o impacto
# na diminui√ß√£o do consumo em hor√°rios de maior demanda. Unidade: kW.

# DscObjetivo: Detalhamento dos objetivos do projeto (ex.: "Reduzir 20% do consumo em ilumina√ß√£o
# de vias p√∫blicas"). Explica as metas pretendidas. Unidade: Texto.

# DscJustificativa: Racional e import√¢ncia do projeto (ex.: "Necessidade de modernizar sistemas
# de ilumina√ß√£o para redu√ß√£o de custos"). Unidade: Texto.

# DatInicioProjeto: Data de in√≠cio oficial do projeto (ex.: "2022-01-01"). Mostra quando o
# projeto foi iniciado. Unidade: Data (YYYY-MM-DD).

# DatConclusaoProjeto: Data oficial de t√©rmino do projeto (ex.: "2022-12-31"). Indica a
# conclus√£o das atividades planejadas. Unidade: Data (YYYY-MM-DD).

# DscMetodologiaMv: Metodologia utilizada para medir e verificar os resultados do projeto
# (ex.: "An√°lise baseada em medi√ß√µes em campo"). Garante confiabilidade dos dados reportados.
# Unidade: Texto.


# Visualizando as primeiras linhas dos dados
head(dados)

# Visualizando as colunas dos dados
colnames(dados)

# Visualizando a estrutura dos dados
str(dados)

# Visualizando 5 elementos de cada coluna que n√£o sejam NA
lapply(dados, function(col) head(na.omit(col), 5))

#####################################################
##### 3. Limpeza e Pr√©-processamento dos Dados #####
#####################################################

# Salvando uma c√≥pia dos dados originais
dados_completos <- dados

# 2. Convers√£o de colunas num√©ricas (char para num√©rico)
# Identificando as colunas que deveriam ser num√©ricas mas est√£o como character
colunas_numericas <- c("IdeEmpresaProponenteProjeto", "VlrBeneficioEnergiaEconomizada", "VlrRcb", "VlrDemandaReduzidaPonta")

# Convertendo as colunas para num√©ricas, tratando os pontos e v√≠rgulas
dados_completos[, colunas_numericas] <- lapply(dados_completos[, colunas_numericas], function(x) as.numeric(gsub(",", ".", gsub("\\.", "", x))))

# Converter vari√°veis para os tipos corretos
dados_completos$DatGeracaoConjuntoDados <- as.Date(dados_completos$DatGeracaoConjuntoDados, format = "%Y-%m-%d")
dados_completos$DatInicioProjeto <- as.Date(dados_completos$DatInicioProjeto, format = "%Y-%m-%d")
dados_completos$DatConclusaoProjeto <- as.Date(dados_completos$DatConclusaoProjeto, format = "%Y-%m-%d")

# Visualizando novamente a estrutura dos dados
str(dados_completos)

# Tratamento de valores NA - Imputa√ß√£o com MICE

# Selecionando apenas algumas para imputa√ß√£o
# colunas_pmm <- c("VlrBeneficioEnergiaEconomizada", "VlrRcb", "VlrDemandaReduzidaPonta")
# dados_pmm <- dados_completos[, colunas_pmm]

# head(dados_pmm)

# # Imputa√ß√£o m√∫ltipla para lidar com valores ausentes
# imputed_data <- mice(dados_pmm, method = "pmm", seed = 500)
# dados_completos[, colunas_pmm] <- complete(imputed_data, 1)


# Criar coluna de dura√ß√£o do projeto (em dias)
dados_completos <- dados_completos %>%
  mutate(DuracaoProjeto = as.numeric(DatConclusaoProjeto - DatInicioProjeto))

# Visualizando novamente a estrutura dos dados
str(dados_completos)

# Resumo estat√≠stico dos dados tratados
summary(dados_completos)

# 1. Contagem de valores nulos por coluna
colSums(is.na(dados_completos))

# 2. Porcentagem de valores nulos por coluna
colSums(is.na(dados_completos)) / nrow(dados_completos) * 100.0


### Analisando as colunas num√©ricas representativas de efici√™ncia energ√©tica
### Percebemos os seguintes n√≠veis de dados ausentes (NA):

### VlrBeneficioEnergiaEconomizada: 67.2%
### VlrRcb: 18.1%
### VlrDemandaReduzidaPonta: 0.5%

### Devido √† extensa quantidade de dados ausentes na vari√°vel VlrBeneficioEnergiaEconomizada,
### optamos por n√£o trabalhar com essa vari√°vel, de tal forma que vamos remov√™-la do conjunto dados_completos.

dados_completos <- dados_completos[, -c(which(colnames(dados_completos) == "VlrBeneficioEnergiaEconomizada"))]


### Analisando vari√°veis categ√≥ricas
### Objetivo: excluir vari√°veis categ√≥ricas com poucos dados da nossa an√°lise


# Tabela de frequ√™ncias para vari√°veis categ√≥ricas
table(dados_completos$DscTipologia)

# Resultado:

#    Aquecimento Solar            Baixa Renda             Co-gera√ß√£o
#                   35                   1599                      3
#  Com√©rcio e Servi√ßos Diagn√≥stico Energ√©tico            Educacional
#                 1937                      1                     13
#   Ilumina√ß√£o P√∫blica             Industrial          Poder P√∫blico
#                 1007                    333                   2511
#          Priorit√°rio         Projeto Piloto            Residencial
#                    4                     23                    658
#                Rural      Servi√ßos P√∫blicos
#                  102                    486

# Vamos agrupar as seguintes Tipologias por baixa disponibilidade de dados para an√°lise como sendo "Outros"
# (menos de 100 exemplares):
#  - Aquecimento Solar
#  - Co-gera√ß√£o
#  - Diagn√≥stico Energ√©tico
#  - Educacional
#  - Priorit√°rio
#  - Projeto piloto



### Analisando uso final

table(dados_completos$DscUsoFinal)

# Resultado:
#       Aquecimento             Aquecimento de √Ågua
#                15                             387
#     Ar Comprimido           Condicionamento de Ar
#                15                             923
#      For√ßa Motriz Gera√ß√£o por Fontes Incentivadas
#               339                             635
# Gest√£o Energ√©tica                      Ilumina√ß√£o
#                 1                            4870
#            Outros                      Reciclagem
#               734                              26
#      Refrigera√ß√£o
#               767

# Vamos transformar todas as categorias de Uso Final com menos de 30 exemplares em "Outros":
#  - Aquecimento
#  - Ar comprimido
#  - Gest√£o energ√©tica
#  - Reciclagem




# Transformando tipologias com menos de 100 exemplares em "Outros"
tipologias_outros <- c("Aquecimento Solar", "Co-gera√ß√£o", "Diagn√≥stico Energ√©tico", "Educacional", "Priorit√°rio", "Projeto Piloto")
dados_completos$DscTipologia <- ifelse(dados_completos$DscTipologia %in% tipologias_outros, "Outros", dados_completos$DscTipologia)

# Transformando categorias de Uso Final com menos de 30 exemplares em "Outros"
usos_finais_excluir <- c("Aquecimento", "Ar Comprimido", "Gest√£o Energ√©tica", "Reciclagem")
dados_completos$DscUsoFinal <- ifelse(dados_completos$DscUsoFinal %in% usos_finais_excluir, "Outros", dados_completos$DscUsoFinal)


#################################
##### 4. An√°lise Descritiva #####
#################################

# Sum√°rio estat√≠stico
summary(dados_completos[, sapply(dados_completos, is.numeric)])

# Tabela de frequ√™ncias para vari√°veis categ√≥ricas
table(dados_completos$DscTipologia)
table(dados_completos$DscUsoFinal)

# Medidas de dispers√£o e assimetria
Desc(dados_completos$VlrRcb)
Desc(dados_completos$VlrDemandaReduzidaPonta)
Desc(dados_completos$DuracaoProjeto)


######################################
##### 5. Visualiza√ß√£o dos Dados: #####
######################################

# Histograma do retorno sobre o custo-benef√≠cio apenas valores diferentes de NA na coluna VlrRcb
# temp_data = dados_completos[!is.na(dados_completos$VlrRcb) & dados_completos$VlrRcb != 0, ]

# Fun√ß√£o para remover outliers
# Essa fun√ß√£o ser√° utilizada para melhorar as visualiza√ß√µes dos dados
# Uma vez que outliers expandem a escala dos gr√°ficos, dificultando a visualiza√ß√£o
# M√©todo utilizado: IQR (Interquartile Range)
remove_outliers <- function(data, column, multiplier = 1.5) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1

  # Definindo limites para detec√ß√£o de outliers
  lower_bound <- Q1 - multiplier * IQR
  upper_bound <- Q3 + multiplier * IQR

  # Filtrando os dados para remover outliers
  data <- data %>%
    filter(data[[column]] >= lower_bound & data[[column]] <= upper_bound)

  return(data)
}

# Histograma do retorno sobre o custo-benef√≠cio (excluindo outliers)
temp_data <- remove_outliers(dados_completos, "VlrRcb")
ggplot(temp_data, aes(x = VlrRcb)) +
  geom_histogram(bins = 30, fill = "lightgreen", color = "black") +
  labs(title = "Histograma do Retorno sobre o Custo-Benef√≠cio", x = "Retorno (R$)", y = "Frequ√™ncia")

# Histograma da demanda reduzida no pico (excluindo outliers)
temp_data <- remove_outliers(dados_completos, "VlrDemandaReduzidaPonta")
ggplot(temp_data, aes(x = VlrDemandaReduzidaPonta)) +
  geom_histogram(bins = 30, fill = "lightgreen", color = "black") +
  labs(title = "Histograma da Demanda Reduzida no Pico", x = "Demanda (kW)", y = "Frequ√™ncia")

# Boxplot da dura√ß√£o do projeto por tipologia
temp_data <- remove_outliers(dados_completos, "DuracaoProjeto")
ggplot(temp_data, aes(x = DscTipologia, y = DuracaoProjeto)) +
  geom_boxplot() +
  labs(title = "Dura√ß√£o do Projeto por Tipologia", x = "Tipologia", y = "Dura√ß√£o (dias)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# Boxplot do retorno sobre o custo-benef√≠cio por tipologia (excluindo outliers)
temp_data <- remove_outliers(dados_completos, "VlrRcb")
ggplot(temp_data, aes(x = DscTipologia, y = VlrRcb)) +
  geom_boxplot() +
  labs(title = "Retorno sobre o Custo-Benef√≠cio por Tipologia", x = "Tipologia", y = "Retorno (R$)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# Boxplot da demanda reduzida no pico por tipologia (excluindo outliers)
temp_data <- remove_outliers(dados_completos, "VlrDemandaReduzidaPonta")
ggplot(temp_data, aes(x = DscTipologia, y = VlrDemandaReduzidaPonta)) +
  geom_boxplot() +
  labs(title = "Demanda Reduzida no Pico por Tipologia", x = "Tipologia", y = "Demanda (kW)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# Gr√°fico de barras da tipologia do projeto
ggplot(dados_completos, aes(x = DscTipologia)) +
  geom_bar(fill = "lightgreen", color = "black") +
  labs(title = "Tipologias dos Projetos", x = "Tipologia", y = "Contagem") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# Scatter plot (exemplo)
ggplot(dados_completos, aes(x = VlrBeneficioEnergiaEconomizada, y = DuracaoProjeto)) +
  geom_point() +
  labs(title = "Rela√ß√£o entre Benef√≠cio e Dura√ß√£o do Projeto", x = "Benef√≠cio (R$)", y = "Dura√ß√£o (dias)")

# Gr√°ficos para atender aos objetivos:


# Gr√°fico 1.1.
# Boxplot do retorno sobre o custo-benef√≠cio por tipologia (excluindo outliers) - Atende ao objetivo 1 e 3
temp_data <- remove_outliers(dados_completos, "VlrRcb")
ggplot(temp_data, aes(x = DscTipologia, y = VlrRcb)) +
  geom_boxplot() +
  labs(title = "Retorno sobre o Custo-Benef√≠cio por Tipologia", x = "Tipologia", y = "Retorno (R$)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_hline(yintercept = mean(temp_data$VlrRcb, na.rm = TRUE), linetype = "dashed", color = "red")


# Gr√°fico 1.2.
# Boxplot da demanda reduzida no pico por tipologia (excluindo outliers) - Atende ao objetivo 1
temp_data <- remove_outliers(dados_completos, "VlrDemandaReduzidaPonta")
ggplot(temp_data, aes(x = DscTipologia, y = VlrDemandaReduzidaPonta)) +
  geom_boxplot() +
  labs(title = "Demanda Reduzida no Pico por Tipologia", x = "Tipologia", y = "Demanda (kW)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_hline(yintercept = mean(temp_data$VlrDemandaReduzidaPonta, na.rm = TRUE), linetype = "dashed", color = "red")


# Gr√°fico 2.1.
# Gr√°fico de barras da tipologia do projeto - contribui para objetivo 2
ggplot(dados_completos, aes(x = DscTipologia)) +
  geom_bar(fill = "lightgreen", color = "black") +
  labs(title = "Frequ√™ncia das Tipologias de Projeto", x = "Tipologia", y = "Contagem") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) # Adiciona contagem em cada barra

# Gr√°fico 2.2.
# Gr√°fico de barras para DscUsoFinal - contribui para objetivo 2
ggplot(dados_completos, aes(x = DscUsoFinal)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Uso Final da Energia nos Projetos", x = "Uso Final", y = "Contagem") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) # Adiciona contagem em cada barra


# Gr√°fico 3.1
# Scatter plot para analisar a rela√ß√£o entre retorno e demanda reduzida (excluindo outliers) - Atende objetivo 3
temp_data <- dados_completos %>%
  filter(!is.na(VlrRcb) & !is.na(VlrDemandaReduzidaPonta)) %>%
  remove_outliers("VlrRcb") %>%
  remove_outliers("VlrDemandaReduzidaPonta")
ggplot(temp_data, aes(x = VlrRcb, y = VlrDemandaReduzidaPonta)) +
  geom_point() +
  labs(title = "Rela√ß√£o entre Retorno e Demanda Reduzida", x = "Retorno (R$)", y = "Demanda Reduzida (kW)") +
  geom_smooth(method = "lm", se = FALSE, color = "red") # Adiciona linha de regress√£o


####################################
##### 5. An√°lise de Correla√ß√£o #####
####################################

# Matriz de correla√ß√£o para vari√°veis num√©ricas
cor(dados_completos[, sapply(dados_completos, is.numeric)], use = "pairwise.complete.obs")

# Visualizac√£o da matriz de correla√ß√£o em mapa de calor
ggcorr(data = dados_completos[, sapply(dados_completos, is.numeric)])

# Conclu√≠mos que os dados apresentados n√£o mostram grande correla√ß√£o entre as vari√°veis num√©ricas.


####################################
##### 6. Resultados da an√°lise #####
####################################


# Sobre as Tipologias

# As tipologias de projetos que apresentam maior e menor retorno sobre o investimento (ROI)


# Auxiliados pelo gr√°fico 1.1. e pelo seguinte c√°lculo:
# Calculando o ROI m√©dio por tipologia em ordem decrescente
temp_data <- remove_outliers(dados_completos, "VlrRcb")
roi_por_tipologia <- temp_data %>%
  group_by(DscTipologia) %>%
  summarise(ROI_Medio = mean(VlrRcb, na.rm = TRUE)) %>%
  arrange(desc(ROI_Medio))

# Mostrando os ROIs m√©dios por tipologia
print(roi_por_tipologia)

# As tipologias de projetos que apresentam maior retorno sobre o investimento (ROI)
#  - Poder P√∫blico: m√©dia de 0.628
#  - Servi√ßos P√∫blicos: 0.623
#  - Outros (incluem as seguintes tipologias: Aquecimento Solar, Co-gera√ß√£o, Diagn√≥stico Energ√©tico, Educacional, Priorit√°rio, Projeto piloto): m√©dia de 0.619
#  - Com√©rcio e Servi√ßos: m√©dia de 0.614

# As tipologias de projetos que apresentam menor retorno sobre o investimento (ROI)
#  - Ilumina√ß√£o P√∫blica: m√©dia de 0.321
#  - Rural: m√©dia de 0.493



# As tipologias de projetos que apresentam maior e menor redu√ß√£o na demanda

# Auxiliados pelo gr√°fico 1.2. e pelo seguinte c√°lculo:
# Calculando a redu√ß√£o m√©dia na demanda por tipologia em ordem decrescente
temp_data <- remove_outliers(dados_completos, "VlrDemandaReduzidaPonta")
reducao_demanda_por_tipologia <- temp_data %>%
  group_by(DscTipologia) %>%
  summarise(RedDemanda_Media = mean(VlrDemandaReduzidaPonta, na.rm = TRUE)) %>%
  arrange(desc(RedDemanda_Media))

# Mostrando a redu√ß√£o m√©dia na demanda por tipologia
print(reducao_demanda_por_tipologia)

# As tipologias de projetos que apresentam maior redu√ß√£o na demanda
#  - Ilumina√ß√£o P√∫blica: m√©dia de 67.8 kW
#  - Baixa Renda: m√©dia de 62.8 kW

# As tipologias de projetos que apresentam menor redu√ß√£o na demanda
#  - Com√©rcio e Servi√ßos: m√©dia de 25.9 kW
#  - Poder P√∫blico: m√©dia de 31.1 kW


# Sobre as Lacunas

# Auxiliados pelo Gr√°fico 2.1. e pelo seguinte c√°lculo
# Contagem de projetos por tipologia
contagem_tipologia <- dados_completos %>%
  group_by(DscTipologia) %>%
  summarise(Contagem = n()) %>%
  arrange(desc(Contagem))

print(contagem_tipologia)

# Tipologias com mais projetos
#  - Poder P√∫blico: 2511 projetos
#  - Com√©rcio e Servi√ßos: 1937 projetos
#  - Baixa renda: 1599 projetos

# Tipologias com menos projetos
#  - Outros (incluem as seguintes tipologias: Aquecimento Solar, Co-gera√ß√£o, Diagn√≥stico Energ√©tico, Educacional, Priorit√°rio, Projeto piloto): 79 projetos
#  - Rural: 102 projetos


# Auxiliados pelo Gr√°fico 2.2. e pelo seguinte c√°lculo
# Contagem de projetos por uso final
contagem_uso_final <- dados_completos %>%
  group_by(DscUsoFinal) %>%
  summarise(Contagem = n()) %>%
  arrange(desc(Contagem))

print(contagem_uso_final)

# Uso final com mais projetos
#  - Ilumina√ß√£o: 4870 projetos
#  - Condicionamento de Ar: 923 projetos

# Uso final com menos projetos
#  - For√ßa Motriz: 339 projetos
#  - Aquecimiento de √Ågua: 387 projetos



########################################
##### 7. Conclus√£o e Recomenda√ß√µes #####
########################################


# Conclus√µes:

# An√°lise de Retorno sobre Investimento (ROI) e Redu√ß√£o de Demanda:
# A an√°lise revelou uma grande varia√ß√£o no ROI entre as diferentes tipologias de projetos de efici√™ncia energ√©tica.
# Projetos do setor p√∫blico ("Poder P√∫blico" e "Servi√ßos P√∫blicos") apresentaram, em m√©dia, os maiores retornos,
# sugerindo que investimentos nessas √°reas podem ser particularmente eficazes.
# Por outro lado, projetos de "Ilumina√ß√£o P√∫blica" mostraram um ROI significativamente menor,
# indicando a necessidade de uma revis√£o estrat√©gica nesse setor.

# Em rela√ß√£o √† redu√ß√£o da demanda, "Ilumina√ß√£o P√∫blica" e "Baixa Renda" se destacaram,
# enquanto "Com√©rcio e Servi√ßos" e "Poder P√∫blico" apresentaram redu√ß√µes menores,
# sugerindo que as estrat√©gias empregadas nestes √∫ltimos setores podem necessitar de aprimoramentos.
# A discrep√¢ncia entre o alto ROI do setor p√∫blico e sua relativamente baixa redu√ß√£o de demanda
# sugere que outros fatores al√©m da redu√ß√£o de consumo direto contribuem para o retorno do investimento nesses projetos.


# Identifica√ß√£o de Lacunas:  A an√°lise de frequ√™ncia das tipologias de projetos destaca um desequil√≠brio na aloca√ß√£o de recursos.
# H√° uma concentra√ß√£o significativa de projetos em "Poder P√∫blico", "Com√©rcio e Servi√ßos" e "Baixa Renda",
# enquanto outras categorias ("Outros", "Rural") recebem uma aten√ß√£o consideravelmente menor.
# Essa concentra√ß√£o pode indicar a necessidade de expandir o escopo do programa para alcan√ßar outros setores e contextos,
# promovendo uma maior equidade na distribui√ß√£o dos benef√≠cios da efici√™ncia energ√©tica.
# Da mesma forma, a an√°lise do uso final da energia revela uma preponder√¢ncia de projetos focados em ilumina√ß√£o,
# enquanto outros usos finais, como for√ßa motriz e aquecimento de √°gua, t√™m menor representatividade,
# indicando √°reas potenciais para expans√£o e diversifica√ß√£o das a√ß√µes de efici√™ncia energ√©tica.


# Recomenda√ß√µes:

# 1. Investiga√ß√£o Adicional sobre Projetos de Ilumina√ß√£o P√∫blica: O baixo retorno sobre o investimento em projetos de ilumina√ß√£o p√∫blica
# justifica uma investiga√ß√£o detalhada sobre as causas dessa baixa performance.
# Isso inclui a an√°lise de custos, m√©todos de implementa√ß√£o, tecnologias empregadas e crit√©rios de sele√ß√£o de projetos.

# 2. Diversifica√ß√£o de Investimentos:
# √â recomendado ampliar o alcance do programa de efici√™ncia energ√©tica,
# direcionando mais recursos para tipologias e usos finais atualmente sub-representados,
# como projetos rurais e aqueles focados em setores al√©m de ilumina√ß√£o e condicionamento de ar.
# Isso promover√° uma maior equidade na distribui√ß√£o dos benef√≠cios e otimizar√° o impacto do programa.

# 3. An√°lise de Dados Mais Granulares:
# Para uma an√°lise mais robusta, a coleta de dados mais detalhados, incluindo informa√ß√µes geogr√°ficas,
# custos espec√≠ficos dos projetos e indicadores de desempenho mais abrangentes,
# √© crucial para refinar as estrat√©gias e otimizar a efic√°cia dos investimentos.

# 4. Monitoramento e Avalia√ß√£o Cont√≠nua:
# A implementa√ß√£o de um sistema de monitoramento e avalia√ß√£o cont√≠nuo do programa de efici√™ncia energ√©tica
# √© essencial para acompanhar o progresso, identificar potenciais problemas e ajustar as estrat√©gias conforme necess√°rio.
# Isso permitir√° o aprimoramento cont√≠nuo do programa e o alcance de resultados mais efetivos.


# Considera√ß√µes Finais:
# Esta an√°lise explorat√≥ria forneceu valiosas informa√ß√µes sobre os padr√µes e tend√™ncias nos projetos de efici√™ncia energ√©tica.
# No entanto, √© importante considerar as limita√ß√µes dos dados dispon√≠veis,
# especialmente a falta de informa√ß√µes geogr√°ficas e a alta porcentagem de valores ausentes em algumas vari√°veis.
# Estudos futuros com dados mais completos e detalhados poder√£o fornecer uma compreens√£o ainda mais aprofundada do tema
# e subsidiar a formula√ß√£o de pol√≠ticas p√∫blicas mais eficazes.

